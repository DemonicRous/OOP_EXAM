## Расскажите про переопределение методов.

> **Переопределение методов в Java** — это механизм, который позволяет подклассу (дочернему классу) переопределить реализацию метода, определённого в суперклассе (родительском классе). Это позволяет дочернему классу адаптировать поведение родительского класса к своим потребностям.

Вот несколько простых и понятных примеров переопределения методов:

> **1. Пример с методом `toString()`:**

Предположим, у нас есть класс `Animal`, который определяет метод `toString()`, возвращающий строку с описанием животного. В подклассе `Dog` мы можем переопределить этот метод, чтобы он возвращал более конкретное описание собаки.

```java
public class Animal {
    public String toString() {
        return "Это животное";
    }
}

public class Dog extends Animal {
    @Override
    public String toString() {
        return "Это собака";
    }
}
```

В этом примере мы создали класс `Animal` с методом `toString()`, который возвращает общую информацию о животном. Затем мы создали подкласс `Dog`, который переопределяет метод `toString()`, чтобы возвращать более конкретную информацию о собаке.

> **2. Пример с методом `equals()`:**

Метод `equals()` используется для проверки равенства двух объектов. Мы можем переопределить его в подклассе, чтобы определить собственное понятие равенства.

```java
class Person {
  private String name;
  public Person(String name) { this.name = name; }
  // ...
  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof Person)) {
      return false;
    } else {
      Person other = (Person) obj;
      return this.name.equals(other.name);
    }
  }
}
```

Здесь мы переопределяем метод `equals()`, чтобы проверять равенство между объектами класса `Person` по их имени.

> **3. Пример с методом `hashCode()`:**

Мы также можем переопределить метод `hashCode()`, если хотим изменить способ вычисления хэш-кода объекта. Это может быть полезно, если мы хотим использовать объект в качестве ключа в хэш-таблице или другом контейнере на основе хэша.

Предположим, у нас есть класс `Person`, который определяет метод `hashCode()` для вычисления хэш-кода на основе имени и возраста человека. В подклассе `Student` мы можем переопределить этот метод, чтобы он учитывал также номер студенческого билета.

```java
class Person {
  private String name;
  private int age;

  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, age);
  }
}

class Student extends Person {
  private long studentId;

  public Student(String name, int age, long studentId) {
    super(name, age);
    this.studentId = studentId;
  }

  @Override
  public int hashCode() {
    return super.hashCode() * 31 + studentId;
  }
}
```

В этом примере мы создали класс `Person` с методом `hashCode()`, который вычисляет хэш-код на основе имени и возраста. Затем мы создали подкласс `Student`, который переопределяет метод `hashCode()`, чтобы учитывать также номер студенческого билета.

> **4. Пример с методом `compareTo()`:**

Метод `compareTo()`, определённый в классе `Comparable`, используется для сравнения двух объектов. Мы можем переопределить его в подклассе, чтобы определить собственный порядок сравнения.

```java
class Person implements Comparable<Person> {
  private String name;
  public Person(String name) { this.name = name; }
  // ...
  @Override
  public int compareTo(Person other) {
    return this.name.compareTo(other.name);
  }
}
```

Здесь мы переопределяем метод `compareTo()`, чтобы сравнивать объекты класса `Person` по их имени.

> **5. Пример с абстрактным методом:**

> **Абстрактный метод** — это метод, который не имеет реализации в родительском классе. Подкласс должен переопределить этот метод и предоставить свою реализацию. 

```java
abstract class Animal {
  abstract void makeSound();
}

class Dog extends Animal {
  @Override
  void makeSound() {
    System.out.println("Гав-гав!");
  }
}
```

В этом примере мы создали абстрактный класс `Animal` с абстрактным методом `makeSound()`, который должен быть переопределён в подклассах. Класс `Dog` переопределяет этот метод, чтобы выводить звук «гав-гав!».

Важно помнить, что при переопределении метода необходимо сохранить сигнатуру метода (имя, параметры и возвращаемый тип), но можно изменить тело метода. Это позволяет дочернему классу адаптировать поведение родительского класса к своим потребностям.









